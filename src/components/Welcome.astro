---
import '@fontsource-variable/fraunces';
import { Vector } from '../code/vector';

const firstName = "Jack";
const lastName = "Kraus";
---

<main>
	<section id="overview">
		<div class="intro align-middle m-auto overlap">
			{firstName.split("").map((char, i) => <h1 class="animated" style={{"animation-delay" : `${i*100}ms`}}>{char}</h1>)}
			<h1>&nbsp;</h1>
			{lastName.split("").map((char, i) => <h1 class="animated" style={`animation-delay: ${(firstName.length+i)*100}ms`}>{char}</h1>)}
		</div>
		<div id="orbitable" class="overlap bg-red-500 w-20 h-20 cursor-move top-2/4 left-2/4">
			<p>Education</p>
		</div>
		
	</section>
	<section></section>
	<section></section>
	<section></section>
</main>

<style>
	body {
		background-color: black;
		height: 1000px;
	}

	

	.intro {
		display: flex;
		align-self: flex-start;
		width: 100%;
		height: 100%;
		justify-content: center;
		align-items: center;
	}

	section {
		width: 100%;
		height: 100vh;
		scroll-snap-align: center;
	}

	.three {
		animation: orbitIn 2s ease-in-out, orbitOut 2s ease-in-out;
	}

	@keyframes fadein {
		0% {
			opacity: 0.01;
			translate: 0px 10px;
		}
		75% {
			translate: 0px -5px;
		}
		100% {
			opacity: 1;
			translate: 0px 0px;
		}
	}

	h1 {
		font-size: 100px;
		color: white;
		display: inline-block;
		font-family: 'Fraunces Variable', serif;
		font-weight: 700;
		
		animation: fadein 600ms ease-in-out both;
	}
</style>

<style is:global>
	.overlap {
		position: absolute;
		top: 0;
		left: 0;
	}
</style>

<script>
import { Vector } from "../code/vector";

	const snapItems = document.querySelectorAll('section');

	window.addEventListener('scroll', () => {
		snapItems.forEach((item) => {
			const rect = item.getBoundingClientRect();
			if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
				document.querySelectorAll<HTMLElement>(".animated").forEach((el) => {
					// reset all animations
					el.style.animationName = 'none';
					el.offsetHeight;
					el.style.animationName = '';

					// play the animation if in current section
					el.style.animationPlayState = item.contains(el) ? "running" : "paused";
				});
			}
		});
	});

	/*
		Needs:
		- Current X and Y
		- Offset of click from item corner
		- Speed X and Y (update each move, and keep on release with friction)
	*/
	class Orbitable {
		offset : Vector;
		speed : Vector;
		anchor : Vector;

		active : boolean;
		element : HTMLElement;

		timestamp : DOMHighResTimeStamp | null;
		animationRequest : number | null;

		constructor(inputElement : HTMLElement) {
			this.offset = new Vector(0, 0);
			this.speed = new Vector(10, 10);
			this.anchor = new Vector(0, 0);

			this.active = false;
			this.element = inputElement;

			this.timestamp = null;
			this.animationRequest = null;
			this.element.style.transform = `translate(900px, 450px) perspective(500px)`;
		}

		pickup(clientX : number, clientY : number) {
			const { top, left } = this.element.getBoundingClientRect();
			
			this.offset.set(clientX - left, clientY - top);
			
			this.speed.set(0, 0);
			this.active = true;

			if (this.animationRequest !== null) {
				cancelAnimationFrame(this.animationRequest);
			}

			this.animationRequest = null;
			this.timestamp = null;
		}

		move(clientX : number, clientY : number) {
			if (this.active) {
				
				const { top, left } = this.element.getBoundingClientRect();
				const { top:pTop, left:pLeft, right:pRight, bottom:pBottom } = this.element.parentElement?.getBoundingClientRect() ?? this.element.getBoundingClientRect();
				console.log(pRight - pLeft, pBottom - pTop);
				const newPos = new Vector(clientX, clientY);
				
				newPos.subtract(this.offset);
				const pCenter = new Vector((pLeft + pRight) / 2, (pBottom + pTop) / 2);
				newPos.subtract(pCenter);
				newPos.clamp(pCenter.y);
				newPos.add(pCenter);

				const newSpeed = new Vector(newPos.x - left, newPos.y - top);
				this.speed.lerpXY(newSpeed.x, newSpeed.y, 0.9);

				this.element.style.transform = `translate(${newPos.x}px, ${newPos.y}px)`;
			}
		}

		release() {
			if (!this.active) return;
			this.active = false;

			const { top, left } = this.element.getBoundingClientRect();
			this.anchor.set(left, top);
			this.speed.clamp(100);

			this.animationRequest = requestAnimationFrame(this.animateStep.bind(this));
		}

		animateStep(timestamp : DOMHighResTimeStamp) {
			if (this.timestamp === null) {
				this.timestamp = timestamp;
			}

			let elapsed = timestamp - this.timestamp;
			
			const a = 5000;
			const b = 50;
			const t = elapsed / 1000;
			if(!this.active && this.speed.length() * b > a * t) {
				
				const ds = this.speed.length() * b * t - a * t * t / 2;
				const dsV = this.speed.copy();

				
				dsV.toLength(ds);
				console.log(this.speed.length());

				this.element.style.transform = `translate(${this.anchor.x + dsV.x}px, ${this.anchor.y + dsV.y}px)`;

				this.animationRequest = requestAnimationFrame(this.animateStep.bind(this));
			}
			else {
				this.active = false;
			}
		}

		clamp(x : number, y : number) {


		}
	}

	const element = document.getElementById("orbitable");
	if (element) {
		const item = new Orbitable(element);
		element?.addEventListener("mousedown", (e) => {
			e.preventDefault();
			item.pickup(e.clientX, e.clientY);
		});
		document.addEventListener("mousemove", (e)=> {
			e.preventDefault();
			item.move(e.clientX, e.clientY);
		});
		document.addEventListener("mouseup", (e) => {
			e.preventDefault();
			item.release();
		});
	}
	

</script>